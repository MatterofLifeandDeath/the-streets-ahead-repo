<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Map with Markers, Offset Dots, Lines, and Labels</title>
<script src="https://cdn.maptiler.com/maptiler-sdk-js/v2.0.3/maptiler-sdk.umd.js"></script>
<link href="https://cdn.maptiler.com/maptiler-sdk-js/v2.0.3/maptiler-sdk.css" rel="stylesheet" />
<style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh; /* Use viewport height for body */
        }
        #map {
            flex: 1; /* Allow map to grow and fill available space */
            width: 100%;
        }
  .mapboxgl-marker-dot {
      width: 10px;
      height: 10px;
      background-color: black;
      border-radius: 50%;
  }

/*PLACE FOR EVENT LOG*/  
  #event-log {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 10px;
      max-height: 200px;
      overflow-y: auto;
      width: 300px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      box-shadow: 0px 0px 5px rgba(0,0,0,0.5);
      z-index: 1;
      opacity: 0
  }

  /* Customizable footer styles */
.custom-footer {
    background-color: #ffffff; /* Footer background color */
    color: #000000; /* Footer text color */
    text-align: left; /* Center align the text */
    padding: 20px; /* Customizable padding for thickness */
    font-size: 18px; /* Footer text size */
    position: fixed; /* Stick the footer to the bottom */
    width: 100%; /* Make the footer full width */
    z-index: 100; /* Set z-index to 100 */
    bottom: 0; /* Align it to the bottom of the page */
}

        /* New text style */
        .footer-text-right {
            text-align: right; /* Align text to the right */
            margin: 0; /* Remove default margin */
            font-size: 10px; /* Match the footer text size */
            color: black; /* Match the footer text color */
            position: absolute; /* Position it absolutely within the footer */
            right: 50px; /* Align it to the right */
            bottom: 20px; /* Adjust as needed */
        }

/* You can adjust the thickness by changing the padding value */

  /* Custom cursor for clickable marker area */
  .mapboxgl-marker-hover {
      cursor: pointer;
  }
</style>
</head>
<body>
    <div id="map"></div>
    <div id="event-log">Event Log:</div>
    <footer class="custom-footer">
        the streets ahead alpha build 1.1
        <div class="footer-text-right">made by Alfie Newson</div>
    </footer>
<script>
    maptilersdk.config.apiKey = 'QNezhfuJxAQ0tvE36I0Q';
    var map = new maptilersdk.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/0350150a-3864-4b90-a34e-4b6f608e59b1/style.json?key=QNezhfuJxAQ0tvE36I0Q', // Custom Map Style
        center: [-0.1276, 51.5072], // Center coordinates (adjusted to match your map)
        zoom: 10 // Initial zoom level
    });

    let lastClickedMarker = { id: null, coordinates: null }; // Variable to store the last clicked marker name and coordinates

// Function to log code execution
function logEvent(code) {
    const logDiv = document.getElementById('event-log');
    const eventMessage = document.createElement('div');
    eventMessage.textContent = code;
    logDiv.appendChild(eventMessage);
    logDiv.scrollTop = logDiv.scrollHeight; // Auto-scroll to the bottom
}
    map.on('load', async function () {
        const defaultMarker = await map.loadImage(
            'https://res.cloudinary.com/dtzh2txcx/image/upload/v1724867783/map-pointer-icon2.png');

        map.addImage('custom-marker', defaultMarker.data);

// Helper function to insert line breaks at word boundaries for any text exceeding the max length
function insertLineBreaks(text, maxLineLength) {
    const words = text.split(' ');
    let currentLine = '';
    let result = '';

    words.forEach(word => {
        // Check if adding the next word would exceed the max line length
        if ((currentLine + word).length > maxLineLength) {
            result += currentLine.trim() + '\n'; // Add current line and a line break
            currentLine = word + ' '; // Start a new line with the current word
        } else {
            currentLine += word + ' '; // Add word to current line
        }
    });

    // Add any remaining text from the last line
    result += currentLine.trim();

    return result;
}

        // Define the marker coordinates and identifiers
        const markerData = [
            { coordinates: [-0.1907456, 51.4633537], name: 'MARKER 1', description: 'Jack', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933004/Jack_tnpyyb.mp3' },
            { coordinates: [-0.1816687, 51.4668878], name: 'MARKER 2', description: 'Lyndon', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933040/Lyndon_m1a0ka.mp3' },
            { coordinates: [-0.1770010, 51.4744475], name: 'MARKER 3', description: 'JJ', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933030/JJ_u0lsoh.mp3' },
            { coordinates: [-0.1690600, 51.4808768], name: 'MARKER 4', description: 'Amelia', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933180/Amelia_ch0wcb.mp3' },
            { coordinates: [-0.1185972, 51.4918941], name: 'MARKER 6', description: 'Daisy', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933200/Daisy_l0h64s.mp3' },
            { coordinates: [-0.096883, 51.503852], name: 'MARKER 7', description: 'Samantha', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933204/Samantha_tdchj6.mp3' },
            { coordinates: [-0.098559, 51.506177], name: 'MARKER 8', description: 'Adina', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933206/Adina_vp8xrc.mp3' },
            { coordinates: [-0.141417, 51.511950], name: 'MARKER 9', description: 'David', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729205619/David_ou6yvs.mp3' },
            { coordinates: [-0.141000, 51.509800], name: 'MARKER 10', description: 'Augustina', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729182787/Augustina_gm3ryq.mp3' },
            { coordinates: [-0.121825, 51.516350], name: 'MARKER 11', description: 'Charlie', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729182767/Charlie_pety5s.mp3' },
            { coordinates: [-0.1491908, 51.5177463], name: 'MARKER 12', description: 'Beverley', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729208154/Beverley_h4o5q0.mp3' },
            { coordinates: [-0.150303, 51.508607], name: 'MARKER 13', description: 'Rory', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729208151/Rory_qleibm.mp3' },
            { coordinates: [-0.156892, 51.517201], name: 'MARKER 14', description: 'Jane', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729208159/Jane_yatbhi.mp3' },
            { coordinates: [-0.140399, 51.528558], name: 'MARKER 15', description: 'Ranya', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729292388/Ranya_l1pq9z.mp3' }
        ];
        const dotlabelData = [
            { coordinates: [-0.1907456, 51.4633537], name: 'MARKER 1', description: 'Jack', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933004/Jack_tnpyyb.mp3' },
            { coordinates: [-0.1816687, 51.4668878], name: 'MARKER 2', description: 'Lyndon', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933040/Lyndon_m1a0ka.mp3' },
            { coordinates: [-0.1770010, 51.4744475], name: 'MARKER 3', description: 'JJ', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933030/JJ_u0lsoh.mp3' },
            { coordinates: [-0.1690600, 51.4808768], name: 'MARKER 4', description: 'Amelia', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933180/Amelia_ch0wcb.mp3' },
            { coordinates: [-0.1185972, 51.4918941], name: 'MARKER 6', description: 'Daisy', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933200/Daisy_l0h64s.mp3' },
            { coordinates: [-0.096883, 51.503852], name: 'MARKER 7', description: 'Samantha', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933204/Samantha_tdchj6.mp3' },
            { coordinates: [-0.098559, 51.506177], name: 'MARKER 8', description: 'Adina', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1728933206/Adina_vp8xrc.mp3' },
            { coordinates: [-0.141417, 51.511950], name: 'MARKER 9', description: 'David', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729205619/David_ou6yvs.mp3' },
            { coordinates: [-0.141000, 51.509800], name: 'MARKER 10', description: 'Augustina', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729182787/Augustina_gm3ryq.mp3' },
            { coordinates: [-0.121825, 51.516350], name: 'MARKER 11', description: 'Charlie', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729182767/Charlie_pety5s.mp3' },
            { coordinates: [-0.1491908, 51.5177463], name: 'MARKER 12', description: 'Beverley', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729208154/Beverley_h4o5q0.mp3' },
            { coordinates: [-0.150303, 51.508607], name: 'MARKER 13', description: 'Rory', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729208151/Rory_qleibm.mp3' },
            { coordinates: [-0.156892, 51.517201], name: 'MARKER 14', description: 'Jane', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729208159/Jane_yatbhi.mp3' },
            { coordinates: [-0.140399, 51.528558], name: 'MARKER 15', description: 'Ranya', url: 'https://res.cloudinary.com/dtzh2txcx/video/upload/v1729292388/Ranya_l1pq9z.mp3' }
        ];

const dotlabelOffsetcoords = dotlabelData.map(marker => ({
coordinates: [marker.coordinates[0] - 0.011, marker.coordinates[1]], // Offset for dot
}));
// Define pink circle data before using it
const pinkCircleData = {
    'type': 'FeatureCollection',
    'features': markerData.map(marker => {
        const offsetCoordinates = [marker.coordinates[0] - 0.01, marker.coordinates[1]]; // Offset by [-0.01, 0.00]
        return {
            'type': 'Feature',
            'geometry': {
                'type': 'Point',
                'coordinates': offsetCoordinates
            },
            'properties': {
                'name': marker.name
            },
        };
    })
};

        // Add a GeoJSON source for the circles
map.addSource('pink-circle', {
    'type': 'geojson',
    'data': pinkCircleData
});

// Add a layer to display the circles
map.addLayer({
    'id': 'pink-circle',
    'type': 'circle',
    'source': 'pink-circle',
    'paint': {
        'circle-radius': 0, // Adjust as needed
        'circle-color': '#000000', // Pink color
        'circle-opacity': 1
    }
});
        
        // Add the markers to the map
        map.addSource('places', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': markerData.map((marker, index) => ({
                    'type': 'Feature',
                    'properties': {
                        'description': `<strong>${marker.description}</strong>`,
                        'name': marker.name, // Unique name for each marker
                        'url': marker.url
                    },
                    'geometry': {
                        'type': 'Point',
                        'coordinates': marker.coordinates
                    }
                }))
            }
        });

        // Add a layer showing the places (markers).
        map.addLayer({
            'id': 'places',
            'type': 'symbol',
            'source': 'places',
            'layout': {
                'icon-image': 'custom-marker',
                'icon-overlap': 'always'
            }
        });

        // Add a clickable area layer for markers with increased radius
        map.addLayer({
            'id': 'marker-hover-area',
            'type': 'circle',
            'source': 'places',
            'paint': {
                'circle-radius': 40, // Larger radius for easier interaction
                'circle-opacity': 0, // 50% opacity to highlight
                'circle-color': '#FF0000' // Red color to highlight
            }
        });

// Create an array to hold the lines between dots and markers
const dotMarkerLines = [];
// Add a GeoJSON source for the lines connecting dots to markers
map.addSource('dot-marker-lines', {
    'type': 'geojson',
    'data': {
    'type': 'FeatureCollection',
    'features': dotMarkerLines
            }
        });

        // Add offset dots, labels, and lines for each marker
        const dotCoordinates = markerData.map((marker, index) => {
            const offsetCoordinates = [marker.coordinates[0], marker.coordinates[1]]; // Offset by [-0.01, 0.00]
    
        // Add a layer to display the lines connecting dots to markers
        map.addLayer({
            'id': 'dot-marker-lines',
            'type': 'line',
            'source': 'dot-marker-lines',
            'layout': {},
            'paint': {
                'line-color': '#000000', // Black color
                'line-width': 1, // 1 pixel thickness
                'line-opacity': 0.5 // 50% opacity
            }
        });


// Update the 'pink-circle' source with all circles
map.getSource('pink-circle').setData(pinkCircleData);


// Preprocess the text to insert line breaks for labels exceeding 52 characters
const maxLineLength = 52; // Maximum number of characters per line
dotlabelData.forEach(dotlabel => {
    dotlabel.name = insertLineBreaks(dotlabel.name, maxLineLength);
});

// Update the dot-labels source with offset coordinates
map.addSource('dot-labels', {
    'type': 'geojson',
    'data': {
        'type': 'FeatureCollection',
        'features': dotlabelData.map(dotlabel => ({
            'type': 'Feature',
            'geometry': {
                'type': 'Point',
                'coordinates': [dotlabel.coordinates[0] - 0.0097, dotlabel.coordinates[1] + 0.00017]

            },
            'properties': {
                'description': dotlabel.description,
                'name': dotlabel.name,
            }
        }))
    }
});

map.addLayer({
    'id': 'dot-labels',
    'type': 'symbol',
    'source': 'dot-labels',
    'layout': {
        'text-field': ['get', 'description'],
        'text-size': 15,
        'text-font': ['Arial Unicode MS Bold', 'Open Sans Regular'],
        'text-offset': [0, 0],
        'text-anchor': 'bottom-left',
        'text-justify': 'left',
        'text-max-width': 35
    },
    'paint': {
        'text-color': '#000000',
        'text-opacity': 0 // Initially hidden
    }
});

    // Define the purple circles GeoJSON data with all marker coordinates
    const purpleCirclesData = {
        'type': 'FeatureCollection',
        'features': markerData.map(marker => ({
            'type': 'Feature',
            'geometry': {
                'type': 'Point',
                'coordinates': marker.coordinates
            },
            'properties': {
                'name': marker.name,
                'id': `Marker${index + 1}` // Unique name for each marker
            }
        }))
    };

    // Add a new source for the purple circles
    map.addSource('purple-circles', {
        'type': 'geojson',
        'data': purpleCirclesData
    });

// Add a new layer to display the purple circles at every marker coordinate
map.addLayer({
    'id': 'purple-circles',
    'type': 'circle',
    'source': 'purple-circles',
    'paint': {
        'circle-radius': 0, // Radius of the circles
        'circle-color': '#800080', // Purple color
        'circle-opacity': 0.3 // 0% opacity
    }
});

// Define a GeoJSON source for the lines connecting the markers
const markerConnectingLines = markerData.flatMap((marker1, index1) =>
            markerData.slice(index1 + 1).map(marker2 => ({
                type: 'Feature',
                geometry: {
                    type: 'LineString',
                    coordinates: [marker1.coordinates, marker2.coordinates],
                },
                properties: {
                    //name: `${marker1.name} <-> ${marker2.name}`//
                }
            }))
        );

        map.addSource('lines', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': markerConnectingLines
            }
        });

        // Add a layer to display the connecting lines
        map.addLayer({
            'id': 'lines',
            'type': 'line',
            'source': 'lines',
            'layout': {},
            'paint': {
                'line-color': '#FF0000', // Red color for lines
                'line-width': 1, // 1 pixel thickness (default)
                'line-opacity': 0.5, // 50% opacity
                'line-dasharray': [2, 2] // Dashed line
            }
        });

        // Add a layer to display the labels at the midpoint of each line
        map.addLayer({
            'id': 'line-labels',
            'type': 'symbol',
            'source': 'lines',
            'layout': {
                'text-field': ['get', 'name'], // Get the line name from properties
                'text-size': 10, // Font size
                'text-anchor': 'center', // Anchor the text in the center
                'symbol-placement': 'line-center', // Place the label at the midpoint of the line
                'text-font': ['Open Sans Regular', 'Arial Unicode MS Regular'] // Font family
            },
            'paint': {
                'text-color': '#FF0000', // Red text color for labels
                'text-halo-color': '#FFFFFF', // White halo around text
                'text-halo-width': 2 // Width of halo
            }
        });

        // Add a clickable area layer for dashed lines
        map.addLayer({
            'id': 'line-hover-area',
            'type': 'line',
            'source': 'lines',
            'paint': {
                'line-width': 15, // Wider clickable area
                'line-opacity': 0 // Fully transparent, just for interaction
            }
        });

// Handle marker click
map.on('click', 'marker-hover-area', function (e) {
    lastClickedMarker.id = e.features[0].properties.name; // Use name instead of id for consistency
    lastClickedMarker.coordinates = e.features[0].geometry.coordinates;

    // Log the code executed
    logEvent(`map.flyTo({ center: ${lastClickedMarker.coordinates}, zoom: 15, essential: true });`);

    // Zoom into the marker
    map.flyTo({
        center: lastClickedMarker.coordinates,
        zoom: 15,
        essential: true
    });
});


// HANDLE DASHED LINE CLICK AND REVERSE ANIMATIONS
map.on('click', 'line-hover-area', function (e) {
    if (map.getZoom() === 15) {
        const lineName = e.features[0].properties.name;
        const [markerName1, markerName2] = lineName.split(' <-> ');

        // Find the marker name that is NOT the last clicked marker
        const otherMarkerName = markerName1 === lastClickedMarker.id ? markerName2 : markerName1;

        // Find the coordinates of the other marker
        const coordsToFly = markerData.find(marker => marker.name === otherMarkerName).coordinates;

        // Log the event
        logEvent(`Dashed line clicked: ${lineName}`);

        // Fly to the other marker's coordinates if different from last clicked
        if (coordsToFly && coordsToFly.toString() !== lastClickedMarker.coordinates.toString()) {
            map.flyTo({
                center: coordsToFly,
                zoom: 15,
                essential: true
            });
        }

// Reverse the circle scaling animation
map.setPaintProperty('pink-circle', 'circle-radius', [
    'interpolate',
    ['linear'],
    ['zoom'],
    10, // Zoom level at which the reverse scaling starts
    6,  // Final radius (reversed)
    15, // Zoom level at which the reverse scaling ends
    0  // Initial radius (reversed)
]);

        // Trigger the purple circle animation
        animatePurpleCirclesToMarkers();
    }
});
// Trigger the purple circle animation
function animatePurpleCirclesToMarkers() {
    // 1. Retrieve all marker coordinates
    const markerCoordinates = markerData.map(marker => ({
        coordinates: marker.coordinates,
        name: marker.name // Assuming `name` is the unique identifier
    }));

    logEvent(`Marker data: ${JSON.stringify(markerData)}`);
    logEvent(`Marker coordinates got: ${JSON.stringify(markerCoordinates)}`);

    // 2. Retrieve purple circle coordinates from the map's source
    const source = map.getSource('purple-circles');
    if (source) {
        const data = source._data;

        // Extract purple circle coordinates and names
        const sourceCoordinates = data.features.map(feature => ({
            coordinates: feature.geometry.coordinates,
            name: feature.properties.name // Assuming `name` is used as the unique ID
        }));
        logEvent(`Source data coordinates and IDs: ${JSON.stringify(sourceCoordinates)}`);

        // 3. Compare coordinates and animate mismatched pairs
        sourceCoordinates.forEach(sourceCoordinate => {
            // Find matching marker by name
            const matchingMarker = markerCoordinates.find(marker => marker.name === sourceCoordinate.name);

            // If a marker is found and coordinates are different, animate the purple circle
            if (matchingMarker && !coordinatesEqual(sourceCoordinate.coordinates, matchingMarker.coordinates)) {
                animateCircleToCoordinates(sourceCoordinate, matchingMarker.coordinates);
            }
        });
    } else {
        logEvent('Source "purple-circles" not found.');
    }
}

// Helper function to compare two sets of coordinates
function coordinatesEqual(coord1, coord2) {
    return coord1[0] === coord2[0] && coord1[1] === coord2[1];
}

// Function to animate a purple circle to marker coordinates
function animateCircleToCoordinates(purpleCircle, targetCoordinates, duration = 800) {
    const startCoordinates = purpleCircle.coordinates;
    const startTime = performance.now();

    function step(currentTime) {
        const elapsedTime = currentTime - startTime;
        const progress = Math.min(elapsedTime / duration, 1);

        // Interpolate current coordinates based on progress
        const currentCoordinates = [
            startCoordinates[0] + (targetCoordinates[0] - startCoordinates[0]) * progress,
            startCoordinates[1] + (targetCoordinates[1] - startCoordinates[1]) * progress
        ];

        // Update purple circle's position
        updatePurpleCirclesCoordinates(purpleCircle.name, currentCoordinates);

        // Update the start of the dot-marker-line
        updateLineStart(purpleCircle.name, currentCoordinates);

        // Continue animation if not yet finished
        if (progress < 1) {
            requestAnimationFrame(step);
        }
    }

    // Start the animation
    requestAnimationFrame(step);
}

// Function to update the purple circle coordinates on the map
function updatePurpleCirclesCoordinates(circleId, newCoordinates) {
    const source = map.getSource('purple-circles');
    if (source) {
        const data = source._data;

        // Update the specific purple circle's coordinates
        const updatedFeatures = data.features.map(feature => {
            if (feature.properties.name === circleId) {
                feature.geometry.coordinates = newCoordinates;
            }
            return feature;
        });

        // Set updated data back to the source
        source.setData({
            type: 'FeatureCollection',
            features: updatedFeatures
        });
    }
}

// Function to update the start of the dot-marker-line
function updateLineStart(circleId, newCoordinates) {
    const source = map.getSource('dot-marker-line-source');
    if (source) {
        const data = source._data;

        // Update the start coordinates of the line matching the purple circle's ID
        const updatedFeatures = data.features.map(feature => {
            if (feature.properties.name === circleId) {
                feature.geometry.coordinates[0] = newCoordinates; // Update the start of the line
            }
            return feature;
        });

        // Set updated data back to the source
        source.setData({
            type: 'FeatureCollection',
            features: updatedFeatures
        });
    }
}


// Log query of dot-labels
logEvent('Querying rendered dot-labels...');

    // Check if the layer name is correct
    if (!map.getLayer('dot-labels')) {
    console.error('Layer "dot-labels" not found!');
    return; // Exit early if the layer is missing
    }

    map.queryRenderedFeatures({ layers: ['dot-labels'] }).forEach(function (feature) {
    const labelName = feature.properties.name; // Ensure you're accessing the correct property

    // Manually evaluate the opacity condition based on feature properties
    let opacity = 0; // Default opacity
    if (labelName === "Marker 1") {
        opacity = 1; // Opacity based on the case expression logic
    }

    logEvent(`Checking dot-label ID: ${labelName}, resolved opacity: ${opacity}`);

    // If opacity is greater than 0, animate it to 0
    if (opacity > 0) {
        logEvent(`Animating dot-label ID: ${labelName} from opacity ${opacity} to 0`);
        
        let currentOpacity = opacity;
        const animationInterval = setInterval(() => {
            currentOpacity -= 0.1; // Decrease opacity gradually
            if (currentOpacity <= 0) {
                currentOpacity = 0;
                clearInterval(animationInterval); // Stop animation at 0 opacity
            }
            
            try {
                // Try to set the opacity property
                map.setPaintProperty('dot-labels', 'text-opacity', currentOpacity, labelName);
            } catch (error) {
                // Log error if the command fails
                console.error(`Failed to set opacity for dot-label ID: ${labelName}. Error: ${error}`);
            }
        }, 50); // Adjust time interval for smooth animation
    }});
        // Handle mouse move events to detect cursor position and interaction
        map.on('mousemove', function (e) {
            const features = map.queryRenderedFeatures(e.point, { layers: ['marker-hover-area', 'line-hover-area'] });
            const isOverMarker = features.some(feature => feature.layer.id === 'marker-hover-area');
            const isOverLine = features.some(feature => feature.layer.id === 'line-hover-area');

            if (isOverMarker) {
                map.getCanvas().style.cursor = 'pointer'; // Pointer cursor for markers
            } else if (isOverLine) {
                map.getCanvas().style.cursor = 'pointer'; // Pointer cursor for lines
            } else {
                map.getCanvas().style.cursor = ''; // Default cursor
            }
        });

// Define a counter for marker clicks
let clickCounter = 0;

// Consolidated click handler for marker clicks
map.on('click', 'marker-hover-area', function (e) {
    const clickedMarkerCoordinates = e.features[0].geometry.coordinates;
    const clickedMarkerNames = e.features[0].properties.name;
    const clickedMarkerURL = e.features[0].properties.url;
    const clickedMarkerDescription = e.features[0].properties.description;
    // Log the URL and check if it is empty
    if (clickedMarkerURL) {
        logEvent('Audio URL retrieved successfully:', clickedMarkerURL);
    } else {
        logEvent('Audio URL is missing or empty for marker:', clickedMarkerNames);
    }logEvent(`Marker DESCRIPTION: ${clickedMarkerDescription}`);

    clickCounter++;

    // Log the code execution for debugging purposes
    logEvent(`Clicked marker at coordinates: ${clickedMarkerCoordinates}`);
    logEvent(`Clicked marker name: ${clickedMarkerNames}`);

    // Step 1: Filter the dotlabelData for a name match with clickedMarkerNames
    const labelMarkerNameMatch = dotlabelData.find(dotLabel => dotLabel.name === clickedMarkerNames);
    const markerNameMatch = labelMarkerNameMatch ? labelMarkerNameMatch.name : null; // Safely get name
    // Log the found label's name (if any) between step 1 and step 2

    // Step 2: Check if a match was found
    if (markerNameMatch) {
        // Step 3: If a match is found, animate the fade-in for the matching dot label
        logEvent(`Marker name match found: ${markerNameMatch}`);
    } else {
        // Step 4: If no match is found, log the event
        logEvent('No marker name match found');
    }


    // Trigger all animations after 3 clicks
    if (clickCounter === 3) {
        clickCounter = 0; // Reset counter after animations

        // Trigger animations
        animatePinkCircle(markerNameMatch);  // Animate pink circle
        animatePurpleCircles(clickedMarkerCoordinates); // Animate purple circle
        animateFadeIn(markerNameMatch);  // Pass the matched label

        // Call the playAudio function to play the associated audio
        playAudio(clickedMarkerURL);

    }

    // Fly to the clicked marker
    map.flyTo({
        center: clickedMarkerCoordinates,
        zoom: 15,
        essential: true
    });

});

// Variable to track the currently playing audio
let currentAudio = null;

// Function for playing audio files
function playAudio(clickedMarkerURL) {
    // Stop the currently playing audio (if any)
    if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0; // Reset the audio to the start
    }

    // Create a new audio element
    currentAudio = new Audio(clickedMarkerURL);

    // Play the new audio
    currentAudio.play().catch(function (error) {
        console.error('Error playing audio:', error);
    });
}



/* Consolidated animation functions */

function animatePurpleCircles(clickedCoordinates) {
    const duration = 2800;
    const startTime = performance.now();

    // Retrieve the existing purple circles data
    const purpleCirclesData = map.getSource('purple-circles')._data;
    const targetData = JSON.parse(JSON.stringify(purpleCirclesData));

    // Adjust target coordinates for the animation
    targetData.features.forEach(feature => {
        feature.geometry.coordinates[0] -= 0.01; // Move target to the left by 0.01
    });

    function animate(time) {
        const elapsedTime = time - startTime;
        const t = Math.min(elapsedTime / duration, 1); // Normalize time between 0 and 1

        // Apply exaggerated cubic ease-out function
        const easeOutT = 1 - Math.pow(1 - t, 9); // Exaggerate cubic ease-out

        // Interpolate features with ease-out
        const interpolatedData = JSON.parse(JSON.stringify(purpleCirclesData));
        interpolatedData.features.forEach((feature, index) => {
            const originalCoords = purpleCirclesData.features[index].geometry.coordinates;
            const targetCoords = targetData.features[index].geometry.coordinates;

            const tolerance = 0.001;
if (Math.abs(originalCoords[0] - clickedCoordinates[0]) < tolerance && Math.abs(originalCoords[1] - clickedCoordinates[1]) < tolerance) {
    // Proceed with the animation

            feature.geometry.coordinates[0] = originalCoords[0] + easeOutT * (targetCoords[0] - originalCoords[0]);
        }
        });

        // Update purple circles
        map.getSource('purple-circles').setData(interpolatedData);

        // Update dotMarkerLines with new start coordinates
        const updatedLines = dotMarkerLines.map((lineFeature, index) => {
            const purpleCirclesCoords = interpolatedData.features[index].geometry.coordinates;
            return {
                ...lineFeature,
                geometry: {
                    ...lineFeature.geometry,
                    coordinates: [purpleCirclesCoords, lineFeature.geometry.coordinates[1]]
                }
            };
        });

        // Update the source with new line data
        map.getSource('dot-marker-lines').setData({
            'type': 'FeatureCollection',
            'features': updatedLines
        });

        if (t < 1) {
            requestAnimationFrame(animate);
        }
    }

    requestAnimationFrame(animate);
}

// Function to animate pink circle scaling for the matching marker name
function animatePinkCircle(name) {
    // Ensure pink circle source is loaded
    if (!map.getSource('pink-circle')) {
        logEvent('Pink circle source not available');
        return;
    }

    setTimeout(() => {
        // Animate circle radius for the matching pink circle based on the 'name' property
        map.setPaintProperty('pink-circle', 'circle-radius', [
            'interpolate',
            ['linear'],
            ['zoom'],
            10,  // Start zoom level
            0,   // Initial radius
            15,  // End zoom level
            6    // Final radius
        ]);

        // Apply filter for the matching circle (by name)
        map.setFilter('pink-circle', [
            '==', ['get', 'name'], name  // Apply only to the circle with matching name
        ]);
    }, 0); // Add delay if needed to synchronize with other animations

    logEvent(`Animating pink circle for name: ${name}`);
}



// Function to animate fade-in for the specific text label by name
function animateFadeIn(name) {
    setTimeout(() => {
        // Fade-in effect for the specific label with matching name
    
        map.setPaintProperty('dot-labels', 'text-opacity', [
            'case',
            ['==', ['get', 'name'], name], // Check if the label's 'name' matches
            1,  // Fade in the matching label
            0   // Keep other labels hidden
        ]);
    }, 1200);
    logEvent(`Fading in label with name: ${name}`);
}

// Initialize dotMarkerLines between markers and purple circles
markerData.forEach((marker, index) => {
    const purpleCircle = purpleCirclesData.features.find(pCircle => pCircle.properties.name === marker.name);

    if (purpleCircle) {
        dotMarkerLines.push({
            'type': 'Feature',
            'geometry': {
                'type': 'LineString',
                'coordinates': [marker.coordinates, purpleCircle.geometry.coordinates], // Line from marker to purple circle
            },
            'properties': {
                'name': marker.name, // Matching name for both marker and purple circle
                'identifier': marker.name
            }
        });
    }
});

// Add a GeoJSON source for the dot-marker-lines
map.addSource('dot-marker-lines', {
    'type': 'geojson',
    'data': {
        'type': 'FeatureCollection',
        'features': dotMarkerLines
    }
});

// Add a layer to display the lines connecting dots to markers and purple circles
map.addLayer({
    'id': 'dot-marker-lines',
    'type': 'line',
    'source': 'dot-marker-lines',
    'layout': {},
    'paint': {
        'line-color': '#000000', // Black color
        'line-width': 1, // 1 pixel thickness
        'line-opacity': 0.5 // 50% opacity
    }
})});

        // Function to create a black dot element
        function createDotElement() {
            const dot = document.createElement('div');
            dot.className = 'mapboxgl-marker-dot';
            return dot;
        }
        })
</script>
</body>
</html>
